/**
 * Tests for StalenessChecker service.
 *
 * Validates staleness detection for auto-generated skills (hash mismatch,
 * source missing, non-auto-generated) and conflict resolution where
 * manual skills always win over auto-generated ones.
 */

import { describe, it, expect } from 'vitest';
import { StalenessChecker } from './staleness-checker.js';
import { computeContentHash } from './types.js';
import type { SkillMetadata } from '../types/skill.js';

/**
 * Helper: create a SkillMetadata object that looks auto-generated
 * with a generatedFrom block in the gsd-skill-creator extension.
 */
function makeAutoGeneratedMetadata(
  name: string,
  sourceFile: string,
  contentHash: string
): SkillMetadata {
  return {
    name,
    description: `Auto-generated skill: ${name}`,
    metadata: {
      extensions: {
        'gsd-skill-creator': {
          enabled: true,
          version: 1,
          generatedFrom: {
            sourceFile,
            contentHash,
            generatedAt: '2026-01-15T00:00:00Z',
          },
        },
      },
    },
    source: 'auto-generated',
  } as SkillMetadata & { source: string };
}

/**
 * Helper: create a SkillMetadata object for a manually created skill.
 */
function makeManualMetadata(name: string): SkillMetadata {
  return {
    name,
    description: `Manual skill: ${name}`,
    metadata: {
      extensions: {
        'gsd-skill-creator': {
          enabled: true,
          version: 1,
        },
      },
    },
  };
}

describe('StalenessChecker', () => {
  const checker = new StalenessChecker();

  describe('checkStaleness', () => {
    it('returns fresh when source hash matches stored hash', () => {
      const sourceContent = '# Research on API patterns\n\nContent here...';
      const hash = computeContentHash(sourceContent);
      const metadata = makeAutoGeneratedMetadata('api-patterns', 'research/api.md', hash);

      const result = checker.checkStaleness(metadata, sourceContent);

      expect(result.isStale).toBe(false);
      expect(result.reason).toBe('fresh');
      expect(result.skillName).toBe('api-patterns');
      expect(result.actualHash).toBe(hash);
      expect(result.expectedHash).toBe(hash);
    });

    it('returns hash_mismatch when source content has changed', () => {
      const originalContent = '# Original research\n\nV1 content';
      const updatedContent = '# Updated research\n\nV2 content with new findings';
      const originalHash = computeContentHash(originalContent);
      const metadata = makeAutoGeneratedMetadata('research-skill', 'research/doc.md', originalHash);

      const result = checker.checkStaleness(metadata, updatedContent);

      expect(result.isStale).toBe(true);
      expect(result.reason).toBe('hash_mismatch');
      expect(result.skillName).toBe('research-skill');
      expect(result.expectedHash).toBe(originalHash);
      expect(result.actualHash).toBe(computeContentHash(updatedContent));
    });

    it('returns source_missing when sourceContent is null', () => {
      const hash = computeContentHash('some content');
      const metadata = makeAutoGeneratedMetadata('missing-source', 'research/gone.md', hash);

      const result = checker.checkStaleness(metadata, null);

      expect(result.isStale).toBe(true);
      expect(result.reason).toBe('source_missing');
      expect(result.skillName).toBe('missing-source');
      expect(result.expectedHash).toBe(hash);
    });

    it('returns not_auto_generated for manually created skills', () => {
      const metadata = makeManualMetadata('my-manual-skill');

      const result = checker.checkStaleness(metadata, 'some content');

      expect(result.isStale).toBe(false);
      expect(result.reason).toBe('not_auto_generated');
      expect(result.skillName).toBe('my-manual-skill');
    });

    it('extracts generatedFrom from gsd-skill-creator extension correctly', () => {
      const sourceContent = 'Specific research content for hash check';
      const hash = computeContentHash(sourceContent);
      const metadata = makeAutoGeneratedMetadata('ext-check', 'research/ext.md', hash);

      const result = checker.checkStaleness(metadata, sourceContent);

      expect(result.isStale).toBe(false);
      expect(result.reason).toBe('fresh');
      expect(result.sourceFile).toBe('research/ext.md');
      expect(result.expectedHash).toBe(hash);
      expect(result.actualHash).toBe(hash);
    });
  });

  describe('resolveConflict', () => {
    it('manual skill wins when both manual and auto-generated exist', () => {
      const result = checker.resolveConflict(
        { name: 'my-skill' },
        { name: 'my-skill', source: 'auto-generated' }
      );

      expect(result.winner).toBe('manual');
      expect(result.skillName).toBe('my-skill');
      expect(result.reason).toBe('Manual skill takes precedence over auto-generated');
    });

    it('auto-generated wins when no manual skill exists', () => {
      const result = checker.resolveConflict(
        null,
        { name: 'auto-only', source: 'auto-generated' }
      );

      expect(result.winner).toBe('auto-generated');
      expect(result.skillName).toBe('auto-only');
    });

    it('manual wins when no auto-generated skill exists', () => {
      const result = checker.resolveConflict(
        { name: 'manual-only' },
        null
      );

      expect(result.winner).toBe('manual');
      expect(result.skillName).toBe('manual-only');
    });

    it('throws when neither skill is provided', () => {
      expect(() => checker.resolveConflict(null, null)).toThrow(
        'At least one skill must be provided'
      );
    });
  });
});
