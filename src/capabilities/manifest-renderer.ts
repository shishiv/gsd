/**
 * Deterministic markdown renderer for CapabilityManifest.
 *
 * Converts a CapabilityManifest into CAPABILITIES.md content with
 * YAML frontmatter and markdown tables. Same input always produces
 * byte-identical output for staleness detection.
 */

import matter from 'gray-matter';
import type {
  CapabilityManifest,
  SkillCapability,
  AgentCapability,
  TeamCapability,
} from './types.js';

// ============================================================================
// Markdown Escaping
// ============================================================================

/**
 * Escape a string for safe inclusion in a markdown table cell.
 *
 * - Replaces `|` with `\|` to prevent column splitting
 * - Replaces newlines (`\n`, `\r`) with space to prevent row splitting
 */
function escapeMarkdown(value: string): string {
  return value.replace(/\|/g, '\\|').replace(/[\n\r]+/g, ' ');
}

// ============================================================================
// Section Renderers
// ============================================================================

/**
 * Render the Skills section as markdown lines.
 */
function renderSkillsSection(skills: SkillCapability[]): string[] {
  const lines: string[] = ['## Skills', ''];

  if (skills.length === 0) {
    lines.push('No skills discovered.', '');
    return lines;
  }

  lines.push('| Name | Scope | Description | Hash |');
  lines.push('|------|-------|-------------|------|');

  for (const skill of skills) {
    lines.push(
      `| ${escapeMarkdown(skill.name)} | ${skill.scope} | ${escapeMarkdown(skill.description)} | ${skill.contentHash} |`
    );
  }

  lines.push('');
  return lines;
}

/**
 * Render the Agents section as markdown lines.
 */
function renderAgentsSection(agents: AgentCapability[]): string[] {
  const lines: string[] = ['## Agents', ''];

  if (agents.length === 0) {
    lines.push('No agents discovered.', '');
    return lines;
  }

  lines.push('| Name | Scope | Description | Tools | Model | Hash |');
  lines.push('|------|-------|-------------|-------|-------|------|');

  for (const agent of agents) {
    lines.push(
      `| ${escapeMarkdown(agent.name)} | ${agent.scope} | ${escapeMarkdown(agent.description)} | ${agent.tools ?? '-'} | ${agent.model ?? '-'} | ${agent.contentHash} |`
    );
  }

  lines.push('');
  return lines;
}

/**
 * Render the Teams section as markdown lines.
 */
function renderTeamsSection(teams: TeamCapability[]): string[] {
  const lines: string[] = ['## Teams', ''];

  if (teams.length === 0) {
    lines.push('No teams discovered.', '');
    return lines;
  }

  lines.push('| Name | Scope | Description | Topology | Members | Hash |');
  lines.push('|------|-------|-------------|----------|---------|------|');

  for (const team of teams) {
    lines.push(
      `| ${escapeMarkdown(team.name)} | ${team.scope} | ${escapeMarkdown(team.description ?? '-')} | ${team.topology ?? '-'} | ${team.memberCount} | ${team.contentHash} |`
    );
  }

  lines.push('');
  return lines;
}

// ============================================================================
// Public API
// ============================================================================

/**
 * Render a CapabilityManifest as a markdown string with YAML frontmatter.
 *
 * The output is deterministic: same input always produces byte-identical output.
 * Uses gray-matter to produce correctly formatted YAML frontmatter.
 *
 * @param manifest - The capability manifest to render
 * @returns Complete CAPABILITIES.md content string
 */
export function renderManifest(manifest: CapabilityManifest): string {
  const bodyLines: string[] = [];

  // Header
  bodyLines.push('# Capabilities', '');
  bodyLines.push(
    '> Auto-generated by gsd-skill-creator. Do not edit manually.'
  );
  bodyLines.push('> Regenerate: `skill-creator capabilities generate`');
  bodyLines.push('');

  // Sections
  bodyLines.push(...renderSkillsSection(manifest.skills));
  bodyLines.push(...renderAgentsSection(manifest.agents));
  bodyLines.push(...renderTeamsSection(manifest.teams));

  const body = bodyLines.join('\n');

  // Frontmatter
  const frontmatter = {
    version: manifest.version,
    generatedAt: manifest.generatedAt,
    contentHash: manifest.contentHash,
  };

  return matter.stringify(body, frontmatter);
}
