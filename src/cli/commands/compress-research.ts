/**
 * CLI command for compressing research files into distilled skill files.
 *
 * Reads a research markdown file, compresses it via ResearchCompressor,
 * checks for conflicts with existing skills via StalenessChecker,
 * and writes the output via SkillStore.
 *
 * Flags:
 * - --dry-run / -d: Show what would be generated without writing
 * - --project / -p: Write to project-level skills (.claude/skills/)
 * - --max-size=N: Override max output bytes (default 5000)
 */

import { readFile } from 'fs/promises';
import * as p from '@clack/prompts';
import pc from 'picocolors';
import { ResearchCompressor } from '../../capabilities/research-compressor.js';
import { StalenessChecker } from '../../capabilities/staleness-checker.js';
import { SkillStore } from '../../storage/skill-store.js';
import { getSkillsBasePath } from '../../types/scope.js';
import type { SkillMetadata } from '../../types/skill.js';

// ============================================================================
// Types
// ============================================================================

export interface CompressResearchOptions {
  /** Skills directory override (for testing) */
  skillsDir?: string;
  /** Output directory override (for testing) */
  outputDir?: string;
}

// ============================================================================
// Main Command
// ============================================================================

/**
 * Compress a research file into a distilled skill.
 *
 * @param args - CLI arguments: [filePath, ...flags]
 * @param options - Optional configuration (for testing)
 * @returns Exit code (0 success, 1 error)
 */
export async function compressResearchCommand(
  args: string[],
  options?: CompressResearchOptions,
): Promise<number> {
  // Parse flags
  const dryRun = args.includes('--dry-run') || args.includes('-d');
  const project = args.includes('--project') || args.includes('-p');
  const maxSizeArg = args.find(a => a.startsWith('--max-size='));
  const maxSize = maxSizeArg ? parseInt(maxSizeArg.split('=')[1], 10) : 5000;

  // First non-flag arg is the research file path
  const filePath = args.find(a => !a.startsWith('-'));

  if (!filePath) {
    p.log.error('Usage: skill-creator compress-research <file> [--dry-run] [--project] [--max-size=N]');
    return 1;
  }

  p.intro(pc.bgCyan(pc.black(' Research Compression ')));

  // Read the research file
  let content: string;
  try {
    content = await readFile(filePath, 'utf-8');
  } catch {
    p.log.error(`Could not read file: ${filePath}`);
    return 1;
  }

  // Compress
  const compressor = new ResearchCompressor();
  const compressed = compressor.compress(filePath, content, {
    maxOutputBytes: maxSize,
  });

  // Display compression summary
  const ratio = compressed.originalSize > 0
    ? ((1 - compressed.compressedSize / compressed.originalSize) * 100).toFixed(0)
    : '0';
  p.log.message(pc.bold('Compression Summary'));
  p.log.message(`  Skill name:      ${compressed.skillName}`);
  p.log.message(`  Original size:   ${compressed.originalSize.toLocaleString()} bytes`);
  p.log.message(`  Compressed size: ${compressed.compressedSize.toLocaleString()} bytes`);
  p.log.message(`  Ratio:           ${ratio}% reduction`);

  if (dryRun) {
    p.log.message('');
    p.log.message(pc.dim('--- Compressed output preview ---'));
    p.log.message(compressed.body.slice(0, 1000) + (compressed.body.length > 1000 ? '\n...' : ''));
    p.log.message(pc.dim('--- End preview ---'));
    p.outro(pc.dim('Dry run complete. No files written.'));
    return 0;
  }

  // Determine skills directory
  const skillsDir = options?.skillsDir
    ?? options?.outputDir
    ?? getSkillsBasePath(project ? 'project' : 'user');

  const skillStore = new SkillStore(skillsDir);

  // Check for existing skill
  const exists = await skillStore.exists(compressed.skillName);
  if (exists) {
    // Read existing skill to determine if manual or auto-generated
    const existing = await skillStore.read(compressed.skillName);
    const existingSource = (existing.metadata as unknown as Record<string, unknown>).source;
    const isExistingAutoGenerated = existingSource === 'auto-generated';

    if (!isExistingAutoGenerated) {
      // Existing skill is manual -- manual always wins
      const checker = new StalenessChecker();
      const resolution = checker.resolveConflict(
        { name: existing.metadata.name },
        { name: compressed.skillName, source: 'auto-generated' },
      );

      if (resolution.winner === 'manual') {
        p.log.warn(`Skill "${compressed.skillName}" exists as a manual skill. Skipping (manual wins).`);
        p.outro('Done.');
        return 0;
      }
    }

    // Auto-generated exists: overwrite
    p.log.info(`Updating existing auto-generated skill "${compressed.skillName}".`);
  }

  // Build metadata for SkillStore.create()
  // source is a custom field; we pass it as part of the metadata object
  const metadata: SkillMetadata = {
    name: compressed.metadata.name,
    description: compressed.metadata.description,
    metadata: compressed.metadata.metadata,
  } as SkillMetadata;

  // Attach custom source field
  (metadata as unknown as Record<string, unknown>).source = compressed.metadata.source;

  await skillStore.create(compressed.skillName, metadata, compressed.body);

  const outputPath = `${skillsDir}/${compressed.skillName}/SKILL.md`;
  p.log.success(`Wrote compressed skill to ${outputPath}`);
  p.log.message(pc.dim(`Compression ratio: ${ratio}% reduction`));

  p.outro('Done.');
  return 0;
}
